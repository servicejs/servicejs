/**
 * This script processes all .js and .js.map files in ../../lib.
 * It is to be invoked after the ESM output has been generated by the TypeScript compiler.
 * ES modules can only be processed natively by node, if they have the extension .mjs.
 * Since TypeScript currently has no configuration option to change the output extension, this needs to be done manually.
 * The corresponding source maps to each of these files are also update to reflect the renaming and are renamed to .mjs.map,
 * so they don't conflict with the CJS source map files.
 * Hence, we can have all output in one directory and thus a hybrid CJS/ESM package.
 */

const fs = require("fs");
const path = require("path");
const watch = require("node-watch");

/**
 * Reads all files in basePath (which is assumed to be a directory) and recursively for all sub directories
 * @param {string} basePath
 */
const readFilesRecursively = (basePath) => {
    let files = [];
    const fileNames = fs.readdirSync(basePath);
    for (const fileName of fileNames) {
        fullPath = path.join(basePath, fileName);
        files.push(fullPath);
        if (fs.lstatSync(fullPath).isDirectory()) {
            files = files.concat(readFilesRecursively(fullPath));
        }
    }
    return files;
}

/**
 * Swaps the extension in fullPath from oldExt to newExt
 * @param {string} fullPath
 * @param {string} oldExt
 * @param {string} newExt
 */
const changeFileExtension = (fullPath, oldExt, newExt) => {
    const dir = path.dirname(fullPath);
    const baseName = path.basename(fullPath, oldExt);
    return path.join(dir, baseName + newExt);
}

/**
 * Process the JS file at jsPath (so far just renaming it to .mjs)
 * @param {string} jsPath
 */
const processJsFile = (jsPath) => {
    // Compute new path
    const mjsPath = changeFileExtension(jsPath, ".js", ".mjs");
    // Rename file
    fs.renameSync(jsPath, mjsPath);

    // Read the renamed file
    const content = fs.readFileSync(mjsPath).toString();
    // Replace the source map path (if it exists in the file)
    const baseName = path.basename(jsPath);
    const sourceMapFileName = baseName + ".map";
    const newSourceMapFileName = changeFileExtension(sourceMapFileName, ".js.map", ".mjs.map")
    const newContent = content.replace("//# sourceMappingURL=" + sourceMapFileName, "//# sourceMappingURL=" + newSourceMapFileName);
    // Write the new content to the file
    fs.writeFileSync(mjsPath, newContent);

    // Return the path of the generated file
    return mjsPath;
}

/**
 * Process the source map at jsSourceMapPath
 * @param {string} jsSourceMapPath
 */
const processSourceMapFile = (jsSourceMapPath) => {
    // Compute the new file name
    const mjsSourceMapPath = changeFileExtension(jsSourceMapPath, ".js.map", ".mjs.map");
    // Rename the file
    fs.renameSync(jsSourceMapPath, mjsSourceMapPath);

    // First we will change the file name stored inside the source map, so we read the file content
    const content = fs.readFileSync(mjsSourceMapPath);
    // Source maps are JSON, so parse the file
    const sourceMapObj = JSON.parse(content);
    // The file attribute gets renamed from .js to .mjs
    sourceMapObj.file = changeFileExtension(sourceMapObj.file, ".js", ".mjs");
    // Stringify the resulting source map object and write it to the file at the old path
    fs.writeFileSync(mjsSourceMapPath, JSON.stringify(sourceMapObj));

    // Return the path of the generated file
    return mjsSourceMapPath;
}

/**
 * Processes the srcFile
 * If the path ends in .js, it uses processJsFile. If the path end in .js.map, it uses processSourceMapFile. Otherwise, no action is performed
 * If processing happened, the resulting file is moved to libDir.
 * @param {string} srcFile
 * @param {string} libDir
 * @param {string} esmOutputDir
 */
const processFile = (srcFile, libDir, esmOutputDir) => {
    if (srcFile.endsWith(".js")) {
        moveFile(processJsFile(srcFile), esmOutputDir, libDir);
    } else if (srcFile.endsWith(".js.map")) {
        moveFile(processSourceMapFile(srcFile), esmOutputDir, libDir);
    }
}

/**
 * Move the file at fullPath from its location relative to oldBasePath to the same relativeLocation at newBasePath
 * @param {string} fullPath
 * @param {string} oldBasePath
 * @param {string} newBasePath
 */
const moveFile = (fullPath, oldBasePath, newBasePath) => {
    // Compute the new full path
    const newFullPath = path.join.apply(null, [newBasePath].concat(path.relative(oldBasePath, fullPath)));
    // Move the file
    fs.renameSync(fullPath, newFullPath);
}

/**
 * Goes through the list of all files in esmOutputDir and its subdirectories and processes them (without watching the directory for changes)
 * @param {string} libDir
 * @param {string} esmOutputDir
 */
const processAllFilesOnce = (libDir, esmOutputDir) => {
    // Get all file and directory names in esmOutputDir recursively
    const allFiles = readFilesRecursively(esmOutputDir);
    allFiles.forEach((fileName) => processFile(fileName, libDir, esmOutputDir));
}

/**
 * Watch the esmOutputDir and process all updated files
 * @param {string} libDir
 * @param {string} esmOutputDir
 */
const watchFilesAndProcess = (libDir, esmOutputDir) => {
    // Watch the esmOutputDir for file system events
    watch(esmOutputDir, { recursive: true, filter: /\.(js|js.map)/ }, (eventType, filename) => {
        // eventType can be remove or update
        // We're only interested in update events for .js and .js.map files, because then the respective file is generated
        if ((filename) && (eventType === "update")) {
            try {
                if (fs.existsSync(filename)) {
                    processFile(filename, libDir, esmOutputDir);
                }
            } catch (e) {
                console.error(e);
            }
        }
    });

    // Since already existing files will not trigger the watcher, we run processAllFilesOnce() to take care of existing files
    processAllFilesOnce(libDir, esmOutputDir);
}

/**
 * Main script entrypoint
 */
const main = () => {
    // Get the path with the compiled JS files relative to the script path
    const libDir = path.join(".", "lib");
    const esmOutputDir = path.join(".", ".esm");

    if (!fs.existsSync(esmOutputDir)) { return; }
    if (!fs.existsSync(libDir)) {
        fs.mkdirSync(libDir);
    }

    const watchMode = process.argv[process.argv.length - 1] === "-w";
    (watchMode ? watchFilesAndProcess : processAllFilesOnce)(libDir, esmOutputDir);
}

try {
    main();
} catch (e) {
    console.error(e);
}
